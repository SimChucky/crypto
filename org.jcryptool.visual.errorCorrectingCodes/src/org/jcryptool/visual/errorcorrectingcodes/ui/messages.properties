EccMainView_tabGeneralText=Error Correcting Codes
EccMainView_tabMcElieceText=McEliece Cryptosystem
EccMainView_tabHammingText=Hamming Cryptographic System
GeneralEccView_btnNextStep=Next Step
GeneralEccView_btnPrev=Previous Step
GeneralEccView_btnReset=Reset
GeneralEccView_grpErrorCode=Erroneous data transmission
GeneralEccView_grpReceiver=Receiver
GeneralEccView_grpSenderStep=Sender
GeneralEccView_grpTextInfo=Information
GeneralEccView_lblHeader=Error Correcting Codes
GeneralEccView_lblTextDecoded=decode
GeneralEccView_lblTextEncode=encode
GeneralEccView_lblTextOriginal=Original:
GeneralEccView_textHeader=This visual shows the general process of finding and correcting bit errors in data transmissions over a noisy channel using error-correcting codes. With larger linear codes like binary Goppa code ECC is used in the McEliece and Niederreiter crypto schemes to scramble a message (see McEliece tab)\n\n Below you can enter a message and click on the "next step" button to continue.
GeneralEccView_textInfo_step1=The input text is handled as an ASCII encoded bit set. 
GeneralEccView_textInfo_step2=The sender encodes the data according to the selected coding scheme. In this example Hamming code was used, which adds 3 parity check bits to every 4 bits of data. 
GeneralEccView_textInfo_step3=An error gets introduced in the data transmission. Here a single bit in each codeword is flipped (marked in red).
GeneralEccView_textInfo_step4=The receiving end checks for errors by calculating the error syndrome, which also identifies the position of the bit in error. The erroneous bits are detected and flipped to reproduce the correct codewords.
GeneralEccView_textInfo_step5=Lastly the string is decoded by extracting the data bits.
HammingCryptoView_lblHeader=Hamming Code McEliece
HammingCryptoView_btnGeneratePrivateKey=Generate Key
HammingCryptoView_grpEncryption=Bob
HammingCryptoView_grpDecryption=Alice
HammingCryptoView_grpPrivateKey=Private Key
HammingCryptoView_grpPublicKey=Public Key
HammingCryptoView_grpTextInfo=Information
HammingCryptoView_lblEncrypt=Encrypted Bitstring
HammingCryptoView_lblOutput=Decrypted bitstring
HammingCryptoView_lblTextOriginal=Cleartext (hex)
HammingCryptoView_textHeader=This view shows a simplified McEliece Cryptosystem with Hamming code. This is not secure due to the static codewords and only one correctable error per segment. In comparison Goppa code has randomnes due to the nature of irrreducible polynomal over a finite field and can correct multiple errors depending on the codeword length. On the other hand, the function of the algorithm can be easier understood with smaller matrices. Therefor we choose this approach to visualize the McEliece System.\n\nYou can enter any message and the key parameters at the first step or let the program fill them by clicking on "Generate key". Click next to continue.
HammingCryptoView_step1=Enter key parameters or let the application fill in random values by clicking on "generate".
HammingCryptoView_step2=To encrypt the message, Bob performs the following steps:\n1. Bob encodes the message m as a binary string of length n.\n2. Bob computes the vector c' by multiplieing m with the public key G' = S*G*P\n3. Bob generates a random n-bit vector e containing exactly t errors, which is determined by the number of errors the code can correct (1 in this example).\n4. Bob computes the ciphertext as c = C' + e.
HammingCryptoView_step3=Upon receiving an encrypted message, Alice deciphers it by following these steps:\n1. Alice multiplies the ciphertext c' with the inverse of the permutation matrix P.\n2. Alice uses the decoding algorithm to correct the errors in c'.\n3. Alice recovers the original message by multyplying m' with the inverse of S.
McElieceView_lblHeader=McEliece Cryptosystem
McElieceView_textHeader=The McEliece cryptosystem is an asymmetric encryption algorithm that uses linear error correcting codes. Robert McEliece developed the original proposal in 1978 but it was not considered for mainstream cryptography until it was proposed as a candidate for the NIST "post-quantum cryptography standardization". The algorithms security is based on the hardness of decoding a general linear code.\nThe original proposal uses binary Goppa codes, which can be efficiently decoded, by use of Patterson's algorithm if the generator or parity check matrix is known. The biggest disadvantage is that the keys and the encrypted string are much larger than keys of other asymmetric encryption schemes, e.g. RSA.\nThe private key consists of the generator matrix of the Goppa code and two invertible matrices S (scramble) and P (permutate) to disguise it. The product of those three matrices, which cannot easily be reverted if the code is long enough, as well as the maximum number of bit errors form the public encryption key.\n\nYou can enter values or let the program fill the data by clicking on "Generate key", then encrypt or decrypt the message.